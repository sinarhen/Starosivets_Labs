---
outline: deep
---

# Лабораторна робота №4

## Мета

- Вивчити особливості циклічних обчислювальних процесів з розгалуженнями
- Опанувати технологію рекурентних обчислень
- Навчитися розробляти алгоритми та програми розвинення функцій у ряди

## Умова задачі

В обох задваннях треба використовувати рекурентні співвідношення для вирішення.

### Завдання 1

Обчислити значення функції у, розвинувши функцію ex у ряд Тейлора. Визначити похибку.

![image](https://github.com/sinarhen/Starosivets_Labs/assets/105736826/d16b9fc5-a8b4-40cc-9956-af5d78c391f9)

### Завдання 2

Обчислити нескінчений ланцюговий дріб, задавши точність обчислення ( 10^-5) з клавіатури. Ланцюговий дріб виражає число рі.

![image](https://github.com/sinarhen/Starosivets_Labs/assets/105736826/2d1f369f-9947-4a1f-8a20-c6345e098f6b)
![image](https://github.com/sinarhen/Starosivets_Labs/assets/105736826/6000cd77-49c0-4f3e-91cf-f38eb84edf46)


## Аналіз задачі

### Завдання 1

Оскільки **X** може бути менше -2 або більше 1, у таких випадках ми виводимо повідомлення, що немає розв'язку. Для коректного порівняння дробового числа з -2 та 1 ми округлюємо його до меншої кількості цифр після коми, що можлива. Щоб знайти найменшу можливу кількість цифр після коми, ми порівнюємо кількість знаків після коми для початкового значення **X**, кінцевого значення **X** та кроку **X**.

```cpp

```

### Завдання 2

Рекурентні співвідношення можуть стати заплутаними, особливо коли їх кількість зростає. Отже, крім функції `newtonBinomialPower` з рекурентними співвідношеннями, необхідно створити другу функцію, яка перераховує факторіали та ступені на кожній ітерації. Ця функція, `slowBinomialPower`, допоможе нам переконатися, що ми правильно обчислюємо степінь двочлена з використанням рекурентних співвідношень.

## Блок-схема алгоритму програми

### Завдання 1

![Схема](../assets/lab4/diagram-1.png)

### Завдання 2

![Схема](../assets/lab4/diagram-2.png)

## Код програми

```cpp
namespace lab4_1
{
    float y, sv, ev, step, standart, error;

    // Function to calculate arcsin(x)
    float arcsin(float x)
    {
        float sum = x, member = x;
        int n = 1;

        do
        {
            member *= (2 * n - 1) / (2 * n) * (x * x / (2 * n + 1));
            sum += member;
            n++;

            if (fabs(member) < FLT_MIN || fabs(member) > FLT_MAX)
            {
                break;
            }
        } while (fabs(member) >= common::accuracy);

        return sum;
    }

    // Function to perform task 1
    void run()
    {
        cout << "Enter the initial value, end value, and step: ";
        cin >> sv >> ev >> step;

        cout << "Enter the accuracy: ";
        common::enterAccuracy();

        cout << "\n========================================================" << endl;
        cout << " x           y            standart           error" << endl;
        cout << "\n========================================================" << endl;

        for (float x = sv; x <= ev; x += step)
        {
            bool flag = true;
            if (x >= -2 && x < 0)
            {
                y = arcsin(x / 2) / arcsin(2 * x);
                standart = asin(x / 2) / asin(2 * x);
                error = fabs(standart - y);

            }
            else if (x >= 0 && x <= 2)
            {
                y = arcsin(x + 5) / arcsin(x * x);
                standart = asin(x + 5) / asin(x * x);
                error = fabs(standart - y);
            }
            else
            {
                flag = false;
            }

            if (!flag || standart != standart)
            {
                cout << setw(5) << x << setw(15) << "       function not defined" << endl;
            }
            else
            {
                cout << setw(5) << x << setw(15) << y << setw(15) << standart << setw(18) << error << endl;
            }
        }
    }
}
```

## Результат виконання програми

### Завдання 1

![Результат](../assets/lab4/result-1.png)

### Завдання 2

![Результат](../assets/lab4/result-2.png)

## Аналіз достовірності результатів

### Завдання 1

Візьмемо два випадки: коли X = −1 для першої умови та X = 0.4 для другої умови.

$$
y=\left\{\begin{array}{lc}
e^{\operatorname{arctg}(x)}, & -2 \leq x<0, \\
e^{x^2}+1, & 0 \leq x \leq 1 .
\end{array}\right.
$$

---

$$ x = -1 $$
$$ y = e^{\arctan(x)} = e^{\arctan(-1)} $$
$$ = e^{-0.785398164} \approx 0.455938128 $$

---

![Калькулятор](../assets/lab4/calc-1-1.png)

---

$$ x = 0.4 $$
$$ y = e^{x^2} + 1 = e^{0.4^2} + 1 $$
$$ = e^{0.16} + 1 \approx 1.173510871 + 1 $$
$$ \approx 2.173510871 $$

---

![Калькулятор](../assets/lab4/calc-1-2.png)

### Завдання 2

Для тесту ми вокористовуємо A = 4, B = 5, N = 7

---

$$ (4 + 5)^7 = 9^7 = 4782969 $$

$$
\approx 4.78297 * 10^6
$$

---

![Калькулятор](../assets/lab4/calc-2.png)

## Висновки

Прогрмана написана успішно та протестована на достовірність.

Можливі удосконалення:

- Використання рядків для зберігання та обробки чисел з метою збереження точності дробової частини та збільшення максимально допустимого числового значення.
